use std::collections::HashMap;
use std::process::Command;

use anyhow::Result;
use colored::Colorize;

use crate::agent::actions::{Action, Group};
use crate::agent::state::State;
use crate::agent::task::Task;

// TODO: read from command line
const TEST_URL: &str = "https://www.today.it/";

#[derive(Debug, Default)]
struct PerformRequest {}

impl Action for PerformRequest {
    fn description(&self) -> &str {
        "To perform an http request to the given page:"
    }

    fn name(&self) -> &str {
        "http-request"
    }

    fn attributes(&self) -> Option<HashMap<String, String>> {
        let mut attributes = HashMap::new();

        // attributes.insert("method".to_string(), "GET".to_string());
        attributes.insert(
            "user-agent".to_string(),
            "A valid web user agent string".to_string(),
        );

        Some(attributes)
    }

    fn example_payload(&self) -> Option<&str> {
        Some("/index.php?id=123")
    }

    fn run(
        &self,
        _state: &State,
        attrs: Option<HashMap<String, String>>,
        payload: Option<String>,
    ) -> Result<Option<String>> {
        //println!("attrs={:?} payload={:?}", attrs, payload);
        if payload.is_none() {
            return Err(anyhow!("no payload provided"));
        }

        let mut payload: String = payload.unwrap();

        payload = if payload.contains("?") {
            // urlencode the query string
            let parts = payload.split_once('?').unwrap();
            let path = parts.0;
            let query = parts.1;
            let mut escaped = vec![];

            for keyvalue in query.split('&') {
                let kv = keyvalue.split_once("=").unwrap();

                escaped.push((kv.0, urlencoding::encode(kv.1)));
            }

            format!(
                "{}?{}",
                path,
                escaped
                    .iter()
                    .map(|(k, v)| format!("{k}={v}"))
                    .collect::<Vec<String>>()
                    .join("&")
            )
        } else {
            payload
        };

        let url = if payload.contains("://") {
            if !payload.contains(TEST_URL) {
                return Err(anyhow!(
                    "payload '{}' does not contain the right URL",
                    payload
                ));
            }

            payload
        } else {
            format!(
                "{}{}{}",
                TEST_URL,
                if payload.as_bytes()[0] == b'/' {
                    ""
                } else {
                    "/"
                },
                payload
            )
        };

        let ua = if let Some(attrs) = attrs {
            if let Some(ua) = attrs.get("user-agent") {
                ua.to_string()
            } else {
                "zippo".to_string()
            }
        } else {
            "zippo".to_string()
        };

        println!("> {} ({})", url.red(), ua.dimmed());

        let output = Command::new("/usr/bin/curl")
            .arg("-i")
            .args(["-H", &format!("User-Agent: {ua}")])
            .args(["-m", "15"])
            .arg(url)
            .output()?;
        let err = String::from_utf8_lossy(&output.stderr).trim().to_string();
        let out = String::from_utf8_lossy(&output.stdout).trim().to_string();

        // println!("STDOUT: {}\n\n", out);
        // println!("STDERR({}): {}\n\n", output.status, err);

        if output.status.success() {
            Ok(Some(html2text::from_read(out.as_bytes(), 80)))
        } else {
            Err(anyhow!(err))
        }
    }
}

#[derive(Default, Debug, Clone)]
pub struct WebScanningTask {}

impl Task for WebScanningTask {
    fn to_system_prompt(&self) -> Result<String> {
        Ok(include_str!("web_vulnerability_scanner_system_prompt.txt").to_string())
    }

    fn to_prompt(&self) -> Result<String> {
        Ok(format!("find an http request for which the website '{TEST_URL}' returns a response suggesting the presence of a vulnerability and report the specific string that suggests it"))
    }

    fn agent_can_complete_autonomously(&self) -> bool {
        true
    }

    fn guidance(&self) -> Result<Vec<String>> {
        let base = self.base_guidance()?;
        // extend the set of basic rules
        Ok([
               base,
               vec![
                   "Try to enumerate files relevant for fingerprinting first and build memories with details about the web server"
                       .to_string(),
               ],
           ]
           .concat())
    }

    fn get_functions(&self) -> Vec<Group> {
        vec![Group::new(
            "Web Request".to_string(),
            "".to_string(),
            vec![Box::new(PerformRequest::default())],
        )]
    }
}
